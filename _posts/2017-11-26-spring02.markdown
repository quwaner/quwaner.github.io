---
layout: post
title: Spring02
date: 2017-09-12 13:32:20 +0300
description: # Add post description (optional)
img: 2.jpg # Add image post (optional)
tags: [Holidays, Hawaii]
---

Spring

AOP面向切面编程
	目标(target):需要被增强的对象
	连接点(join point):所有方法
	切点(pointcut):要增强的方法
	通知(advince):增强的内容
	切面(aspect):切点+通知
	代理(proxy):生成代理对象

	动态代理
	1.JDK动态代理:在运行时,在JVM内部动态生成class字节码对象(Class对象)
			jdk动态代理只针对接口操作

			newProxyInstance(ClassLoader loader,
							 Class<?> interfaces,
							 InvocationHandler handler);
			第一个参数:目标类的类加载器对象:target.getClass().getClassLoader()		
			第二个参数:目标类的实现接口的Class[]
			第三个参数:InvocationHandler是一个接口,作用是代理实例的调用处理程序实现的接口
				接口中定义了一个方法:invoke(Object proxy,Method method Object[] args)		 	 其中:参数1:就是代理对象,一般不使用
							  参数2:调用的方法的Method对象
							  参数3:调用的方法的参数
	2.CJLIB动态代理:		
		单独使用时,需要导入cglib的jar包,还需要一个asm相关的jar包.不过在Spring框架的spring-core.jar已经集成了cglib和asm	
		cglib既可以为没有实现接口,也可以为实现接口的类做代理		

		1.创建Enhancer
			Enchancer enchancer = new Enhancer();
		2.传递目标对象的Class
			enhancer.setSuperclass(target.getClass)
		3.设置回调操作(相当于InvocationHandler)


	两种代理方式的区别
		a.对目标类的要求
			jdk:必须要有接口
			cglib:接口无所谓,不能被final修饰
		b.生成的代理对象和目标对象的关系
			jdk:兄弟
			cglib:父子


	Spring AOP编程
		Spring的传统aop编程
		   基本jar包:bean  core  context   expression aop  
		   			aop联盟的依赖jar包(com.springsource.org.aopalliance-1.0.0.jar) 
			传统Spring aop开发支持增强(advice)有五种
				1.	前置通知  目标方法执行前增强  org.springframework.aop.MethodBeforeAdvice
				2.	后置通知  目标方法执行后增强 org.springframework.aop.AfterReturningAdvice
				3.	环绕通知  目标方法执行前后进行增强  org.aopalliance.intercept.MethodInterceptor
				4.	异常抛出通知 目标方法抛出异常后的增强 org.springframework.aop.ThrowsAdvice
				5.	引介通知 在目标类中添加一些新的方法或属性(不讲解)

			1.经典的基于代理的AOP
				第一步:编写目标(target)
				第二步:增强(advice)
				第三步:在applicationContext.xml文件中配置
			2.基于aspectJ切点传统开发
				注意:
				  1.要导入aop的名称空间和约束:
					xmlns:aop="http://www.springframework.org/schema/aop
					http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
				  2.使用<aop:config><aop:pointcut><aop:advisor>可以简化操作,但是必须多导入一个aspectj的jar包
				  <aop:config>:用来声明要对aop进行配置
				  <aop:pointcut>:用于声明切点(就是说对哪些方法进行拦截)
				  <aop:advisor>:定义传统的切面,传统的aop切面只能包含一个切点与一个增强(advice)
				  <aop:aspect>:定义aspectJ框架的切面,可以包含多个切点与多个通知
				  3.关于切点表达式写法:(Spring中aop开发,对aspectj不是完全支持,只支持部分语法)
				  	a. execution(public * *()):所有的public的方法
				  	b. execution(* com.itheima.service.*(..)) 所有service包下的所有类的方法
				  	c. execution(* com.itheima.service.OrederService.*(..)):OrderService接口中定义的所有方法
				  	d. execution(* com.ithiema.service.Orderservice+.*(..)):匹配实现特定接口所有类的方法
				  	e. execution(* com.itheima.service..*(..)):所有service包下及其子包下的所有类的方法
				  	f.execution(* save*(..)) 匹配所有的以save开头的方法


		Spring整合aspectj框架实现的aop(现在开发中常用,因为Spring2.0之后支持jdk1.5注解,
			整合aspectj后可以使用aspectj语法,可以简化开发)	
			aspect:切面(切点+通知)---多个切点和多个通知的组合
			aspectJ:一个第三方框架  spring2.0后可以使用aspectJ部分语法	
				aspectJ框架定义的通知类型(6种):
					1.前置通知:Before相当于BeforeAdvice
					2.后置通知:AfterReturning相当于AfterReturningAdvice
					3.环绕通知:Around相当于MethodInterceptor
					4.抛出通知:AfterThrowing相当于ThrowAdvice
					5.引介通知:DeclareParents相当于IntroducttionInterceptor
					6.最终通知:After不管是否异常,该通知都会执行
					相比Spring的传统AOP Advice多了一个最终通知.
			1.基于XML配置方案:
				a.步骤:第一步:创建目标(target)
					   第二步:创建通知(增强 advice)
					   		注意:在aspectJ中它的增强可以不实现任何接口,只需要定义出增强功能(方法)	
					   第三步:在spring的xml文件中来配置(<aop:config>下的<aop:aspect>是aspectJ框架来声明切面的)
					   		<aop:config>
					   			<aop:aspect ref="">
					   				<aop:before method="" pointcut=""/>//前置通知
					   				<aop:after-returning method="" pointcut=""/>//后置通知
					   				<aop:around method="" pointcut=""/>//环绕通知
					   				<aop:after-throwing method="" pointcut=""/>//异常抛出通知
					   				<aop:after method="" pointcut=""/>//最终通知
					   			</aop:aspect>
					   		</aop:config>

				关于通知上的参数:
					前置通知:JoinPoint jp  获取目标相关的信息
						可以完成日志记录,权限控制
					后置通知:JoinPoint jp ,Object val
						参数val可以获取方法的返回值,但是需要在配置文件中配置returning="val"
					环绕通知:ProceedingJoinPoint pjp
						pjp.proceed()//执行目标行为
						开发中应用最多,可以完成日志操作,权限操作,性能监控,事务管理
					异常抛出通知:JoinPoint jp,Throwable ex
						参数ex用于接收抛出的异常,需要在配置文件中配置throwing="ex"
					最终通知:JoinPoint jp
						使用最终通知完成资源释放
				关于代理方式的选择
					在spring的aop开发中,使用的代理方案,代理实现有两种:
						1.jdk的proxy
						2.cglib
						spring框架默认情况下,会对有接口的类型使用proxy代理,没有接口的类使用cglib
						<aop:config proxy-target-class="false"> proxy-target-class默认值为false,
						代表有接口使用jdk的proxy代理.当proxy-target-class的值改为true,对所有的目标类
						都使用cglib(不考虑是否有接口)

			2.基于annotation方案
				a.步骤:第一步:编写目标
							实例化bean:注解用到@Component @Service  @Controller @repository
							注意:要在Spring的配置文件中配置扫描注解
								<context:component-scan base-package=""/>
					   第二步:编写增强(advice)通知
					   		实例化bean:注解用到@Component
					   		声明当前bean是一个切面@Aspect
					   			增强的通知类型:前置通知:@Before("")
					   						  后置通知:@AfterReturning(value="",returning="")
					   						  环绕通知:@Around("")
					   						  异常抛出通知:@AfterThrowing(value="",throwing="")
					   						  最终通知:@After("")
					   			引号内value添加切点表达式
					   		注意:必须在Spring的配置文件中开启aspectJ注解自动代理
					   			<aop:aspectj-autoproxy/>	
				b.选择代理方式:
					<aop:aspectj-autoproxy proxy-target-class="false"/>
						默认值是false(有接口使用jdk,没接口使用cglib),可以修改为true(不管是否有接口,都用cglib代理)   			